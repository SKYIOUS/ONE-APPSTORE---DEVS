# **Building a Multiplatform App Store with GitHub as a Backend**

## **1\. Introduction**

The concept of a multiplatform app store addresses the growing need for users to access applications across various operating systems and devices. The proposal to utilize a public GitHub repository as the storage foundation for such an app store presents an intriguing approach, potentially leveraging the platform's inherent version control and collaborative capabilities. This architecture envisions two primary applications: one for developers to upload and manage their applications (Dev's app), and another for end-users to discover and download these applications (User's app). The fundamental operation of this system would involve pushing and pulling application data from the designated GitHub repository. While this approach offers potential benefits in terms of transparency and developer familiarity with Git, it also introduces unique challenges related to scalability, security within a public context, and the need to replicate functionalities typically provided by dedicated app store platforms. This report aims to provide a comprehensive analysis of the technical feasibility, best practices, and potential alternatives for constructing this multiplatform app store using GitHub as its core infrastructure.

## **2\. Best Practices for Structuring the Public GitHub Repository**

Establishing a well-defined structure for the public GitHub repository is paramount for the success of this multiplatform app store. The primary goal is to create an organization that is both intuitive for end-users seeking applications and manageable for developers contributing their work.1

### **Repository Naming Conventions and Organization**

The main repository serving as the central hub for the app store should have a clear and easily understandable name, such as multiplatform-app-store.1 Employing simple alphanumeric characters along with hyphens or underscores ensures URL compatibility and avoids potential confusion.1 Adhering to a standardized naming convention across the entire repository structure will enhance efficiency and predictability for everyone involved.1 Since GitHub does not inherently support nested repositories in a hierarchical file system manner for individual users within a single project 4, the most practical approach for organization is to utilize subdirectories. Each developer registered on the platform should be assigned a unique identifier by the system. This identifier can then be used to create a top-level subdirectory within the main repository, providing a dedicated space for their applications. To further enhance clarity, these developer-specific subdirectories could follow a naming pattern like dev-developerId1, where developerId1 is the unique identifier.2

### **Utilizing Topics and README Files for Discoverability and Information**

To improve the discoverability of the app store itself, relevant topics should be added to the main repository.1 These topics could include terms like "app-store," "multiplatform," and potentially tags indicating the supported platforms, such as "android-apps" and "ios-apps." A comprehensive README.md file in the main repository is crucial for outlining the project's purpose, providing clear instructions for developers on how to contribute their apps (including the process of linking their own repositories as submodules), and guiding end-users on how to browse and download applications. Licensing information for the overall project and contact details for support should also be included.1 Furthermore, each developer's subdirectory should contain its own README.md file. This file should list the applications offered by that developer, provide concise descriptions for each app, include links to any external documentation or support resources, and potentially offer the developer's contact information.1

### **Strategies for Managing Individual Developer Sub-Repositories**

To fulfill the requirement of each developer having their own sub-repository, the most suitable strategy appears to be the utilization of Git submodules.9 With this approach, each developer would maintain their collection of applications within their own separate Git repository, which could be hosted on GitHub or another Git hosting service (public or private, although for a public app store, public repositories are likely preferred for transparency). The main multiplatform-app-store repository would then contain references to these individual developer repositories as submodules, located within the developer-specific subdirectories (e.g., multiplatform-app-store/dev-developerId1/). This method offers the significant advantage of keeping the commit histories of each developer's app collection separate from the main app store repository and from each other, granting developers full control over their respective projects.9 While alternative strategies like using a monorepo (all apps in subdirectories of the main repository) or Git subtree exist 9, they are less aligned with the user's need for individual "sub-repositories" and could introduce complexities in terms of access control and shared commit history, especially within a public repository.  
Managing Git submodules, however, can introduce a degree of complexity for developers, requiring them to understand specific Git commands for initialization, updating, and pushing changes. To mitigate this potential barrier, the "Dev's app" envisioned by the user should abstract these underlying Git operations. When a developer uses the Dev's app to upload a new application or provide a link to an existing one, the application should handle the necessary Git submodule commands behind the scenes. This would include adding the developer's repository as a submodule (if it's their first app), updating the submodule reference to point to the latest commit in the developer's repository, and committing these changes to the main multiplatform-app-store repository. Similarly, when a developer releases a new version of their app in their own repository, the Dev's app should provide a mechanism for them to update the corresponding submodule reference in the main app store repository.14  
In summary, the recommended structure for the public GitHub repository is a single main repository named something like multiplatform-app-store. Within this repository, each registered developer would have a dedicated subdirectory named using a consistent pattern incorporating their unique ID (e.g., dev-developerId1). This subdirectory would be a Git submodule, linking to the developer's own repository where they manage their applications, potentially organized further by app ID and release channel (stable, beta, etc.).  
**Table 1: Comparison of Repository Management Strategies**

| Strategy | Isolation of Developer Apps | Commit History Management | Management Complexity | Suitability for User's Requirements |
| :---- | :---- | :---- | :---- | :---- |
| Git Submodules | High | Separate per developer | Moderate | High |
| Monorepo | Low | Shared | Low | Low |
| Git Subtree | Medium | Integrated | High | Medium |

## **3\. Implementing GitHub OAuth for Developer Authentication in Mobile Applications**

Securely authenticating developers using their existing GitHub accounts is crucial for the Dev's app. GitHub's OAuth 2.0 implementation provides a standard and secure way to achieve this.23

### **Understanding GitHub OAuth Flows for Native Applications (Android and iOS)**

For native mobile applications like the Dev's app, the recommended OAuth 2.0 flow is the authorization code grant, enhanced with the Proof Key for Code Exchange (PKCE) extension.23 PKCE adds an extra layer of security, particularly important for public clients like mobile apps, by preventing the interception and misuse of authorization codes.24 GitHub supports this standard authorization code grant type 23, and Google also recommends PKCE for native Android applications.24 Therefore, the Dev's app, for both Android and iOS platforms, should implement the OAuth 2.0 authorization code grant flow with PKCE to ensure secure developer authentication.

### **Step-by-step Process and Considerations for Implementation**

The implementation of GitHub OAuth in the Dev's app can be streamlined by leveraging existing Software Development Kits (SDKs).25 Firebase Authentication offers a convenient and often straightforward way to integrate GitHub login into both Android and iOS applications.26 It handles much of the underlying OAuth complexities, requiring developers to register their application as a developer application on GitHub and configure the Firebase OAuth redirect URI as the authorized callback URL in the GitHub app settings.26 Alternatively, for developers seeking more control over the OAuth flow or those not using Firebase, platform-specific OAuth libraries are available. For iOS, libraries like OAuthSwift 25 and AppAuth 27 (which also supports macOS) provide robust implementations of OAuth 2.0 and OpenID Connect, adhering to best practices like RFC 8252 and supporting PKCE. For Android, while Firebase Authentication is an option, developers can also utilize the Google Sign-In library in conjunction with a backend server to manage the exchange of the authorization code for GitHub access tokens, offering greater flexibility in handling token exchange and storage.24 Regardless of the chosen SDK or approach, a fundamental step involves registering the Dev's app as a developer application on GitHub.26 During this registration, it is crucial to configure the correct OAuth redirect URI. This URI is where GitHub will redirect the user back to the Dev's app after they have successfully authorized the application. A mismatch in the redirect URI will cause the authentication process to fail. For Firebase, this URI will be provided by the Firebase console. For other libraries, developers will need to define a custom URL scheme for their application and configure that scheme as the callback URL in the GitHub developer application settings.

## **4\. Programmatic Interaction with the GitHub Repository for App Management**

The Dev's app will need to programmatically interact with the GitHub repository to enable developers to upload their applications or store links to them. This interaction will primarily be through the GitHub REST API.28

### **Leveraging the GitHub REST API for File Uploads and Link Storage**

The GitHub REST API provides a comprehensive set of endpoints for managing repository contents.28 These include endpoints for retrieving the content of files and directories, creating new files, updating existing files, and deleting files. For the Dev's app, these functionalities will be essential for managing the developer submodules and the content within them. When a new developer registers and logs in for the first time, the Dev's app will need to ensure that a dedicated repository for them exists (if they haven't linked an existing one). This operation might occur outside the main app store repository's content API, potentially using the repository creation API if the user opts to have a repository created for them. Subsequently, the Dev's app will need to add this developer repository as a submodule to their designated directory within the main multiplatform-app-store repository. This process involves manipulating the .gitmodules file of the main repository and updating the Git index.29 Insights from 29 suggest that creating a submodule via the API involves a multi-step process of creating a Git tree with the .gitmodules entry, creating a commit referencing this tree, and finally updating the reference (e.g., the main branch) to point to this new commit.  
For developers who choose to upload their application files directly, the Dev's app will need to handle the potential size limitations imposed by the standard GitHub API. The API's content creation and update endpoints have a limit of 100 MB for file size.28 For applications exceeding this limit, the Dev's app will need to integrate with Git Large File Storage (LFS). This involves a more complex workflow, including installing and configuring Git LFS, tracking the large application files, and then using standard Git commands (potentially invoked programmatically through a Git library) to commit and push these files to the developer's repository. For smaller application files (under 100 MB), the Dev's app can use the GitHub REST API's content creation or update endpoint. When using this endpoint, the file content must be encoded in Base64 format.28 If a developer chooses to provide a link to their application file (hosted elsewhere), the Dev's app can simply create a new text file within their submodule containing this link, using the same content creation API endpoint. Additionally, the Dev's app will need to manage metadata associated with the applications, such as descriptions and version information. This can be achieved by creating or updating specific metadata files (e.g., in JSON or YAML format) within the developer's submodule using the REST API.

### **Managing Access Control and Permissions for Developer Sub-Repositories**

The main multiplatform-app-store repository will be public, allowing end-users to browse the available applications. However, write access to this repository, specifically to the individual developer subdirectories, needs to be restricted to the respective developers. GitHub's permission model allows for granular control over who can access and modify a repository.30 Owners and administrators of the main repository can manage collaborators and their permissions. For this system, each developer (or potentially a dedicated service account associated with the Dev's app acting on their behalf) will need to be granted write access only to their designated subdirectory (which is a submodule pointing to their own repository) within the main multiplatform-app-store repository. This can be achieved through GitHub's collaborator settings. The Dev's app itself will need to authenticate its API requests to modify the main repository (e.g., when adding a new developer's submodule) using appropriate credentials, such as a personal access token with the repo scope or a GitHub App installation token with content:write permission. Developers, on the other hand, will manage the content of their own repositories (where their actual app files reside) using their GitHub OAuth tokens obtained during login via the Dev's app.30

## **5\. Strategies for Distributing Multiplatform Applications to End-Users**

Distributing multiplatform applications from a GitHub repository to end-users presents a departure from the traditional app store model.36 The strategy will likely involve direct downloads from the developers' repositories (linked as submodules) within the main app store repository, potentially utilizing GitHub Releases for hosting the application files.

### **Exploring Different Distribution Channels and Methods**

Traditional app stores like Google Play Store for Android and Apple App Store for iOS are the primary channels for reaching a broad audience, offering features like discovery, installation management, updates, and billing.36 However, the user's focus on GitHub suggests an alternative approach, at least initially. For web applications, GitHub Pages provides a simple platform for hosting static websites.36 For native mobile applications, direct distribution methods exist. For Android, this involves hosting APK or AAB files, which users can download and install (though they might need to enable "Install from unknown sources" in their device settings).37 For iOS, direct distribution outside the App Store typically involves creating an IPA file and a corresponding PLIST manifest file, hosting them on a web server (including GitHub Releases), and using a special itms-services:// URL scheme to initiate the installation on the user's device.38

### **Considerations for Android**

Developers can upload their Android application packages (APKs or AABs) to their repositories (linked as submodules). The User's app can then provide a catalog of available Android apps, with direct download links to these files. These links would typically point to the raw content of the files within the developer's repository. It's important to note that for users to install apps downloaded directly (sideloaded) on Android, they usually need to enable the "Install from unknown sources" option in their device settings. The User's app might need to provide clear instructions on how to do this for users who are not familiar with the process.37

### **Considerations for iOS**

For distributing iOS applications, developers would typically create an IPA (iOS App Package) file. To enable direct installation outside the App Store, a PLIST (Property List) file is also required. This PLIST file acts as a manifest, providing metadata about the application and the location of the IPA file. Both the IPA and the PLIST files need to be hosted on a web server accessible via HTTPS. GitHub Releases, a feature that allows developers to package software releases with release notes and links to binary files, can serve as a suitable hosting platform.38 Developers can create a release in their repository containing the IPA and PLIST files. The User's app can then construct the necessary itms-services:// URL using the raw URLs of the PLIST file from the GitHub Release. When a user opens this URL on their iOS device, it will prompt them to install the application. This method is commonly used for beta testing (though Apple's TestFlight service is another popular option for managing beta distribution) and for enterprise application distribution.44

## **6\. Managing App Versions and Release Channels within the GitHub Repository**

Effectively managing different versions and release channels (stable, beta) of the applications within the GitHub repository structure is crucial for both developers and end-users. This can be achieved through a combination of branching strategies and Git tags within each developer's repository (the submodules).

### **Branching Strategies for Stable and Beta Releases**

Within each developer's repository, adopting a clear branching strategy will help manage the different release channels.2 A straightforward approach would be to have a stable branch representing the production-ready version of the application and a beta branch for pre-release versions undergoing testing. The main development work for the application could take place on a main or develop branch. This model allows developers to isolate the different stages of their application's lifecycle, ensuring that the code in the stable branch is the most reliable and user-tested version. The beta branch would contain newer features and bug fixes that are ready for wider testing but not yet considered stable for general release.

### **Utilizing Tags for Versioning**

To further manage and track different versions of the applications, developers should utilize Git tags.52 Each significant release on both the stable and beta branches should be tagged with a semantic version number. For example, a stable release might be tagged as v1.0.0, while a beta release could be tagged as v1.0.0-beta1. GitHub Releases can be created from these Git tags, providing a convenient way to package the software, along with release notes and links to the binary files.52 Tags provide immutable references to specific points in the repository's history, making it easy to identify, track, and revert to previous versions of the application if necessary.

### **Workflow for Promoting Apps Through Different Channels**

A typical workflow for promoting applications through different release channels would involve developers working on new features and bug fixes in their main or develop branch.46 Once these changes are deemed ready for beta testing, they would be merged into the beta branch. After a period of testing and feedback, if the beta version is considered stable, the code from the beta branch would then be merged into the stable branch for the final production release. At each stage, appropriate Git tags should be created to mark the specific version. The Dev's app can potentially provide a user interface that simplifies this promotion process for developers, perhaps by automating the Git merge and tagging operations or providing clear guidance on the necessary steps. This structured approach ensures a controlled and organized release process, allowing developers to effectively manage different versions of their applications across stable and beta channels.

## **7\. Security Considerations and Best Practices for a Public App Store on GitHub**

Building a public app store on GitHub necessitates careful consideration of security to protect both developers and end-users.55

### **Authentication and Authorization Mechanisms**

Enforcing strong authentication for developers is paramount. All developers contributing to the platform should be required to enable two-factor authentication (2FA) on their GitHub accounts.55 The Dev's app should guide developers through this process and securely handle their GitHub OAuth tokens obtained during login, using them only for authorized actions related to their own repositories. It is crucial to emphasize that developers should never hardcode any credentials or store sensitive information directly within their repositories.55 Regular rotation of personal access tokens and SSH keys is also a recommended security practice.55

### **Ensuring Data Integrity and Preventing Unauthorized Modifications**

To maintain the integrity of the applications, especially the stable releases, branch protection rules should be implemented on the stable branch of each developer's repository.7 These rules can prevent direct pushes to the stable branch, requiring all changes to be submitted via pull requests that undergo code review before being merged. This process adds a layer of control and helps ensure that only vetted and approved code makes its way into the stable releases. Additionally, considering the use of signed commits can further enhance data integrity by verifying the authenticity of contributions.55

### **Recommendations for Securing the Repository and Developer Accounts**

Leveraging GitHub's built-in security features is highly recommended.7 Enabling secret scanning can help prevent developers from accidentally committing API keys or other sensitive information to their repositories.55 Setting up vulnerability alerts will notify developers of any known security vulnerabilities in the dependencies used by their applications (though this might require integration with external scanning tools). Furthermore, adding a SECURITY.md file to the main repository provides a clear way to communicate the project's security policies and instructions for users or developers to report any potential vulnerabilities they might discover.7

## **8\. Scalability Analysis of Using GitHub as the App Store Backend**

While GitHub offers a robust platform for version control and collaboration, its suitability as a backend for a growing app store requires careful consideration of its scalability limitations, particularly in terms of storage and bandwidth.69

### **Evaluating Storage and Bandwidth Limitations**

GitHub provides generous storage for Git repositories, but it recommends keeping repositories under 1 GB, with a strong recommendation to stay below 5 GB.69 For individual files, there is a hard limit of 100 MB for standard Git operations.69 While GitHub Pages offers a platform for hosting static websites, it has a size limit of 1 GB and a soft bandwidth limit of 100 GB per month.73 To handle larger files, GitHub provides Git Large File Storage (LFS).70 However, even with LFS, there are storage and bandwidth quotas. Each account using Git LFS receives 1 GB of free storage and 1 GB of free bandwidth per month.70 Exceeding these free quotas will incur additional costs. The maximum size of individual files managed by Git LFS can range from 2 GB to 5 GB depending on the user's GitHub plan.70 For a growing app store with numerous applications and potentially large file sizes, especially for multiplatform apps, the initial free storage and bandwidth offered by GitHub and Git LFS might become a significant limitation. The user will need to closely monitor the storage and bandwidth consumption and be prepared to purchase additional LFS quotas as the app store grows in popularity and the number of applications increases.

### **Addressing Potential Performance Bottlenecks with a Growing Number of Apps and Users**

For large repositories, performance can be impacted, especially during cloning and fetching operations.75 Utilizing Git LFS is crucial for mitigating these performance issues when dealing with large application files.75 GitHub's globally distributed infrastructure and caching mechanisms can help improve download speeds for end-users.75 While techniques like sparse checkouts 75 can be beneficial for developers working within a large monorepo (which is not the proposed architecture), they are less relevant for end-users who will typically be downloading specific applications. The primary performance bottleneck for end-users is likely to be the download speed of the application files, particularly if these files are large and managed by Git LFS. While LFS handles the storage efficiently, the bandwidth for downloading these files will be a key factor in the user experience. As the number of users downloading applications grows, the total bandwidth consumption could become substantial. The user might need to explore options like using a Content Delivery Network (CDN) in front of the GitHub repository (if feasible for direct downloads of LFS objects) to further optimize download speeds and distribute the bandwidth load as the app store scales.

### **Leveraging GitHub LFS for Large App Files**

Git LFS is specifically designed to handle large binary files, such as application packages, by storing references (pointer files) in the Git repository while the actual file content is stored separately on a dedicated server.69 This approach keeps the Git repository size manageable and improves the efficiency of Git operations. Developers will need to be instructed to use Git LFS for all application files that exceed the standard Git file size limit (around 100 MB). When end-users clone the repository, they will only download the pointer files for the large applications. To download the actual application files, they need to have Git LFS installed on their system. The User's app should therefore provide clear instructions to end-users on how to install Git LFS if they encounter any issues downloading applications. Proper and consistent use of Git LFS by developers is essential for the scalability and performance of the proposed app store.  
**Table 2: GitHub LFS Plan Comparison**

| GitHub Plan | Maximum File Size | Free Storage | Free Bandwidth per Month | Considerations for App Store |
| :---- | :---- | :---- | :---- | :---- |
| GitHub Free & Pro | 2 GB | 1 GB | 1 GB | Suitable for smaller apps or limited downloads; potential for exceeding free quota quickly. |
| GitHub Team | 4 GB | 1 GB | 1 GB | Higher file size limit offers more flexibility. |
| GitHub Enterprise Cloud | 5 GB | 1 GB | 1 GB | Largest file size limit; still need to monitor bandwidth and storage. |

## **9\. Exploring Alternative Solutions and Existing Platforms**

While using GitHub as a backend for a multiplatform app store presents a unique approach, it is beneficial to consider alternative solutions and existing platforms to evaluate the trade-offs.83

### **Overview of Existing App Store Platforms and Their Architectures**

Established app store platforms like Google Play Store and Apple App Store have mature, centralized architectures designed specifically for distributing applications to millions of users. They offer a comprehensive suite of features, including app discovery through search and categorization, managed installation processes, automatic updates, developer tools and analytics, and in many cases, integrated billing and payment systems. These platforms handle the complexities of scalability, security, and compliance within their respective ecosystems.36 However, they also come with their own sets of guidelines, submission processes, potential fees, and limitations on the types of applications that can be distributed.

### **Considering Backend-as-a-Service (BaaS) Providers**

Another alternative to using GitHub directly for storing application files is to leverage Backend-as-a-Service (BaaS) providers such as Firebase Storage, AWS S3, Azure Blob Storage, or similar services. These platforms are designed to offer highly scalable and cost-effective storage solutions for binary files and other large assets. In this model, GitHub could still be used for managing the metadata of the app store, version control of the Dev's app and User's app, and potentially storing links to the actual application files hosted on the BaaS provider. This approach could help alleviate the storage and bandwidth limitations associated with GitHub LFS and provide more granular control over access permissions and content delivery.

### **Evaluating the Trade-offs Between GitHub and Dedicated Solutions**

Using GitHub as the backend for an app store offers the advantages of transparency (especially for public repositories), leveraging a platform that many developers are already familiar with, and the inherent version control capabilities of Git. However, it requires significant custom development to replicate the core functionalities of a dedicated app store, such as advanced search, user reviews, automated updates, and potentially billing. Scalability in terms of handling very large application files and high download volumes might also present challenges with GitHub's native limitations and the associated costs of Git LFS. Established app store platforms provide a comprehensive and managed environment for app distribution but come with their own rules and fees. BaaS providers offer scalable storage and delivery infrastructure but might require more integration effort to create a full-fledged app store experience. The choice between these options depends on the user's specific priorities, technical expertise, resources, and the desired scope and features of the multiplatform app store.  
**Table 3: Trade-offs Between GitHub and Dedicated App Store Solutions**

| Feature | GitHub-Based Solution | Dedicated App Store Platform | BaaS Provider (e.g., Firebase Storage) |
| :---- | :---- | :---- | :---- |
| Development Effort | High (requires building many features) | Low (platform provides many features) | Medium (requires integration for features) |
| Scalability | Potential limitations with free tiers of LFS | Highly scalable | Highly scalable |
| Built-in Features | Minimal (requires custom development) | Extensive (discovery, install, updates) | Basic storage and delivery |
| Cost | Potentially lower initial cost, but LFS costs can scale | Potential fees and revenue sharing | Cost based on usage (storage, bandwidth) |
| Transparency | High (for public repositories) | Limited | Can be high depending on implementation |
| Version Control | Excellent (inherent to Git) | Limited to app versions | Requires separate management |
| User Acquisition | Requires custom marketing and linking | Built-in user base and discovery mechanisms | Requires custom marketing and linking |

## **10\. Conclusion**

Building a multiplatform app store with a public GitHub repository as a backend is a technically feasible endeavor, particularly leveraging Git submodules for developer independence and Git LFS for managing large application files. However, it requires careful planning and significant development effort to replicate the functionalities offered by existing app store platforms. While GitHub provides transparency and a familiar environment for developers, scalability in terms of storage and bandwidth, especially for a growing user base and large applications, needs to be closely monitored, and the associated costs of Git LFS should be considered. Security in a public repository context necessitates strict adherence to best practices, including enforced 2FA for developers and robust branch protection rules. The user should carefully weigh the advantages of this innovative approach against the established features and scalability of dedicated app store platforms and the flexible storage options offered by BaaS providers. Starting with a pilot project to test the feasibility, gather data on resource consumption, and assess user experience is a recommended first step before fully committing to this ambitious architecture.

#### **Works cited**

1. GitHub Repository Best Practices \- DEV Community, accessed on April 2, 2025, [https://dev.to/pwd9000/github-repository-best-practices-23ck](https://dev.to/pwd9000/github-repository-best-practices-23ck)  
2. Structuring and Organizing my Github: A Developer's Guide | by Muhammad Ahmed Suhail, accessed on April 2, 2025, [https://medium.com/@muhammadahmedsuhail007/structuring-and-organizing-my-github-a-developers-guide-7353610f04fd](https://medium.com/@muhammadahmedsuhail007/structuring-and-organizing-my-github-a-developers-guide-7353610f04fd)  
3. GitHub Repository Structure Best Practices | by Soulaiman Ghanem | Code Factory Berlin, accessed on April 2, 2025, [https://medium.com/code-factory-berlin/github-repository-structure-best-practices-248e6effc405](https://medium.com/code-factory-berlin/github-repository-structure-best-practices-248e6effc405)  
4. Organizing multiple projects on GitHub \- Software Engineering Stack Exchange, accessed on April 2, 2025, [https://softwareengineering.stackexchange.com/questions/364287/organizing-multiple-projects-on-github](https://softwareengineering.stackexchange.com/questions/364287/organizing-multiple-projects-on-github)  
5. Can I arrange repositories into folders on Github? \- Stack Overflow, accessed on April 2, 2025, [https://stackoverflow.com/questions/11852982/can-i-arrange-repositories-into-folders-on-github](https://stackoverflow.com/questions/11852982/can-i-arrange-repositories-into-folders-on-github)  
6. How to Organize GitHub Repositories, accessed on April 2, 2025, [https://backrightup.com/blog/how-to-organize-github-repositories/](https://backrightup.com/blog/how-to-organize-github-repositories/)  
7. Best practices for repositories \- GitHub Docs, accessed on April 2, 2025, [https://docs.github.com/en/repositories/creating-and-managing-repositories/best-practices-for-repositories](https://docs.github.com/en/repositories/creating-and-managing-repositories/best-practices-for-repositories)  
8. Organizing your repositories — Fancy GitHub documentation \- Jonathan Soma, accessed on April 2, 2025, [https://jonathansoma.com/fancy-github/organization/](https://jonathansoma.com/fancy-github/organization/)  
9. GitHub repository with sub-repositories · community · Discussion \#138119 · GitHub, accessed on April 2, 2025, [https://github.com/orgs/community/discussions/138119](https://github.com/orgs/community/discussions/138119)  
10. Git Submodules basic explanation \- GitHub Gist, accessed on April 2, 2025, [https://gist.github.com/gitaarik/8735255](https://gist.github.com/gitaarik/8735255)  
11. How to Utilize Submodules within Git Repos | by Paige Niedringhaus \- Bits and Pieces, accessed on April 2, 2025, [https://blog.bitsrc.io/how-to-utilize-submodules-within-git-repos-5dfdd1c62d09](https://blog.bitsrc.io/how-to-utilize-submodules-within-git-repos-5dfdd1c62d09)  
12. TIL \#068 – nested git repositories \- mathspp, accessed on April 2, 2025, [https://mathspp.com/blog/til/nested-git-repositories](https://mathspp.com/blog/til/nested-git-repositories)  
13. How to manage Git submodules \- Graphite, accessed on April 2, 2025, [https://graphite.dev/guides/git-submodules](https://graphite.dev/guides/git-submodules)  
14. Submodules \- Git, accessed on April 2, 2025, [https://git-scm.com/book/en/v2/Git-Tools-Submodules](https://git-scm.com/book/en/v2/Git-Tools-Submodules)  
15. Using Git submodules for workflow components \- GitHub Gist, accessed on April 2, 2025, [https://gist.github.com/kaspermunch/1131f20216648bd55bb20f6b35e69252](https://gist.github.com/kaspermunch/1131f20216648bd55bb20f6b35e69252)  
16. How to Use GitHub Submodules for Better Code Management \- YouTube, accessed on April 2, 2025, [https://www.youtube.com/watch?v=QHpAv9AXU5Y](https://www.youtube.com/watch?v=QHpAv9AXU5Y)  
17. Working with submodules \- The GitHub Blog, accessed on April 2, 2025, [https://github.blog/open-source/git/working-with-submodules/](https://github.blog/open-source/git/working-with-submodules/)  
18. Git Submodules: Adding, Using, Removing, Updating \- Chris Jean, accessed on April 2, 2025, [https://chrisjean.com/git-submodules-adding-using-removing-and-updating/](https://chrisjean.com/git-submodules-adding-using-removing-and-updating/)  
19. git-scm.com, accessed on April 2, 2025, [https://git-scm.com/book/en/v2/Git-Tools-Submodules\#:\~:text=There%20is%20an%20easier%20way,fetch%20and%20update%20for%20you.](https://git-scm.com/book/en/v2/Git-Tools-Submodules#:~:text=There%20is%20an%20easier%20way,fetch%20and%20update%20for%20you.)  
20. Add, Update, and Remove Git Submodule | phoenixNAP KB, accessed on April 2, 2025, [https://phoenixnap.com/kb/git-add-remove-update-submodule](https://phoenixnap.com/kb/git-add-remove-update-submodule)  
21. Pull latest changes for all git submodules \- Stack Overflow, accessed on April 2, 2025, [https://stackoverflow.com/questions/1030169/pull-latest-changes-for-all-git-submodules](https://stackoverflow.com/questions/1030169/pull-latest-changes-for-all-git-submodules)  
22. Update Git submodule to latest commit on origin \- Stack Overflow, accessed on April 2, 2025, [https://stackoverflow.com/questions/5828324/update-git-submodule-to-latest-commit-on-origin](https://stackoverflow.com/questions/5828324/update-git-submodule-to-latest-commit-on-origin)  
23. Authorizing OAuth apps \- GitHub Docs, accessed on April 2, 2025, [https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/authorizing-oauth-apps](https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/authorizing-oauth-apps)  
24. OAuth 2.0 for Mobile & Desktop Apps | Authorization \- Google for Developers, accessed on April 2, 2025, [https://developers.google.com/identity/protocols/oauth2/native-app](https://developers.google.com/identity/protocols/oauth2/native-app)  
25. OAuthSwift/OAuthSwift: Swift based OAuth library for iOS \- GitHub, accessed on April 2, 2025, [https://github.com/OAuthSwift/OAuthSwift](https://github.com/OAuthSwift/OAuthSwift)  
26. Authenticate Using GitHub on Android | Firebase Authentication, accessed on April 2, 2025, [https://firebase.google.com/docs/auth/android/github-auth](https://firebase.google.com/docs/auth/android/github-auth)  
27. openid/AppAuth-iOS: iOS and macOS SDK for communicating with OAuth 2.0 and OpenID Connect providers. \- GitHub, accessed on April 2, 2025, [https://github.com/openid/AppAuth-iOS](https://github.com/openid/AppAuth-iOS)  
28. REST API endpoints for repository contents \- GitHub Docs, accessed on April 2, 2025, [https://docs.github.com/en/rest/repos/contents](https://docs.github.com/en/rest/repos/contents)  
29. How to create submodule in GitHub using GitHub Rest Api \- Stack Overflow, accessed on April 2, 2025, [https://stackoverflow.com/questions/35765445/how-to-create-submodule-in-github-using-github-rest-api](https://stackoverflow.com/questions/35765445/how-to-create-submodule-in-github-using-github-rest-api)  
30. Managing teams and people with access to your repository \- GitHub Docs, accessed on April 2, 2025, [https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/managing-repository-settings/managing-teams-and-people-with-access-to-your-repository](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/managing-repository-settings/managing-teams-and-people-with-access-to-your-repository)  
31. GitHub access control management best practices \- Entro Security, accessed on April 2, 2025, [https://entro.security/blog/github-access-management-best-practices/](https://entro.security/blog/github-access-management-best-practices/)  
32. Setting repository visibility \- GitHub Docs, accessed on April 2, 2025, [https://docs.github.com/articles/setting-repository-visibility](https://docs.github.com/articles/setting-repository-visibility)  
33. Configuring a package's access control and visibility \- GitHub Docs, accessed on April 2, 2025, [https://docs.github.com/en/packages/learn-github-packages/configuring-a-packages-access-control-and-visibility](https://docs.github.com/en/packages/learn-github-packages/configuring-a-packages-access-control-and-visibility)  
34. Limiting interactions in your repository \- GitHub Docs, accessed on April 2, 2025, [https://docs.github.com/en/communities/moderating-comments-and-conversations/limiting-interactions-in-your-repository](https://docs.github.com/en/communities/moderating-comments-and-conversations/limiting-interactions-in-your-repository)  
35. How to prevent non contributors from seeing specific files in a public GitHub repo?, accessed on April 2, 2025, [https://stackoverflow.com/questions/70343244/how-to-prevent-non-contributors-from-seeing-specific-files-in-a-public-github-re](https://stackoverflow.com/questions/70343244/how-to-prevent-non-contributors-from-seeing-specific-files-in-a-public-github-re)  
36. Publish your application | Kotlin Multiplatform Development Documentation \- JetBrains, accessed on April 2, 2025, [https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-publish-apps.html](https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-publish-apps.html)  
37. Steps to publish Android and iOS apps to respective stores \- GitHub, accessed on April 2, 2025, [https://gist.github.com/1a319abb5cefd45e88ab47ee89149b37](https://gist.github.com/1a319abb5cefd45e88ab47ee89149b37)  
38. alex-wap/app-store: How-to Guide for Apple App Store Submittal \- GitHub, accessed on April 2, 2025, [https://github.com/alex-wap/app-store](https://github.com/alex-wap/app-store)  
39. appcenter-docs/docs/distribution/stores/apple.md at live \- GitHub, accessed on April 2, 2025, [https://github.com/MicrosoftDocs/appcenter-docs/blob/live/docs/distribution/stores/apple.md](https://github.com/MicrosoftDocs/appcenter-docs/blob/live/docs/distribution/stores/apple.md)  
40. Automating iOS Deployment with App Store Connect API and Github Actions \- Qavi Tech, accessed on April 2, 2025, [https://qavi.tech/automating-ios-deployment-with-app-store-connect-api-and-github-actions/](https://qavi.tech/automating-ios-deployment-with-app-store-connect-api-and-github-actions/)  
41. Deploying Compose Multiplatform WebApp to Github Pages \- YouTube, accessed on April 2, 2025, [https://www.youtube.com/watch?v=4IQ726Y0Jfc](https://www.youtube.com/watch?v=4IQ726Y0Jfc)  
42. Deploy your app to GitHub Pages · Actions · GitHub Marketplace, accessed on April 2, 2025, [https://github.com/marketplace/actions/deploy-your-app-to-github-pages](https://github.com/marketplace/actions/deploy-your-app-to-github-pages)  
43. Simple, self-hosted Android and iOS mobile app distribution server (for IPA and APK files). \- GitHub, accessed on April 2, 2025, [https://github.com/significa/app-distribution-server](https://github.com/significa/app-distribution-server)  
44. Effortlessly Distribute Your iOS App with GitHub: A Step-by-Step Guide \[OTA — over the air\], accessed on April 2, 2025, [https://daihanios.medium.com/effortlessly-distribute-your-ios-app-with-github-a-step-by-step-guide-35a4b09abc28](https://daihanios.medium.com/effortlessly-distribute-your-ios-app-with-github-a-step-by-step-guide-35a4b09abc28)  
45. Proper git workflow scheme with multiple developers working on same task \- Stack Overflow, accessed on April 2, 2025, [https://stackoverflow.com/questions/14865283/proper-git-workflow-scheme-with-multiple-developers-working-on-same-task](https://stackoverflow.com/questions/14865283/proper-git-workflow-scheme-with-multiple-developers-working-on-same-task)  
46. Gitflow Workflow | Atlassian Git Tutorial, accessed on April 2, 2025, [https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow](https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow)  
47. Proper way of structuring different release streams in Git? \- Stack Overflow, accessed on April 2, 2025, [https://stackoverflow.com/questions/41862485/proper-way-of-structuring-different-release-streams-in-git](https://stackoverflow.com/questions/41862485/proper-way-of-structuring-different-release-streams-in-git)  
48. Git branching strategy for maintaining a stable release while continuing product development \- Stack Overflow, accessed on April 2, 2025, [https://stackoverflow.com/questions/78036966/git-branching-strategy-for-maintaining-a-stable-release-while-continuing-product](https://stackoverflow.com/questions/78036966/git-branching-strategy-for-maintaining-a-stable-release-while-continuing-product)  
49. A Scaleable Git Branching Strategy | by Nick Skelton \- Medium, accessed on April 2, 2025, [https://nickskelton.medium.com/iframe-width-420-height-315-src-https-www-youtube-com-embed-fm3d7byzlic-8a81158c1110](https://nickskelton.medium.com/iframe-width-420-height-315-src-https-www-youtube-com-embed-fm3d7byzlic-8a81158c1110)  
50. Git Branching Strategies: GitFlow, Github Flow, Trunk Based... \- AB Tasty, accessed on April 2, 2025, [https://www.abtasty.com/blog/git-branching-strategies/](https://www.abtasty.com/blog/git-branching-strategies/)  
51. Advice for Git branching strategy? : r/ExperiencedDevs \- Reddit, accessed on April 2, 2025, [https://www.reddit.com/r/ExperiencedDevs/comments/11m1pc4/advice\_for\_git\_branching\_strategy/](https://www.reddit.com/r/ExperiencedDevs/comments/11m1pc4/advice_for_git_branching_strategy/)  
52. About releases \- GitHub Docs, accessed on April 2, 2025, [https://docs.github.com/en/repositories/releasing-projects-on-github/about-releases](https://docs.github.com/en/repositories/releasing-projects-on-github/about-releases)  
53. You Should Use Releases on GitHub \- DEV Community, accessed on April 2, 2025, [https://dev.to/jonasbn/you-should-use-releases-on-github-24b1](https://dev.to/jonasbn/you-should-use-releases-on-github-24b1)  
54. In which branch should a beta release be tagged? \- Stack Overflow, accessed on April 2, 2025, [https://stackoverflow.com/questions/39328064/in-which-branch-should-a-beta-release-be-tagged](https://stackoverflow.com/questions/39328064/in-which-branch-should-a-beta-release-be-tagged)  
55. 21 Security Best Practices for GitHub \- Check Point Software Technologies, accessed on April 2, 2025, [https://www.checkpoint.com/cyber-hub/cloud-security/what-is-developer-security/21-security-best-practices-for-github/](https://www.checkpoint.com/cyber-hub/cloud-security/what-is-developer-security/21-security-best-practices-for-github/)  
56. What are GitHub security best practices? \- GitGuardian, accessed on April 2, 2025, [https://www.gitguardian.com/glossary/what-are-github-security-best-practices](https://www.gitguardian.com/glossary/what-are-github-security-best-practices)  
57. 10 GitHub Security Best Practices | Medium \- Sena Yakut, accessed on April 2, 2025, [https://senayakut.com/10-github-security-best-practices-23af1d919df3](https://senayakut.com/10-github-security-best-practices-23af1d919df3)  
58. GitHub Security Best Practices \- 15 Tips To Keep In Mind \- Blog | GitProtect.io, accessed on April 2, 2025, [https://gitprotect.io/blog/github-security-best-practices-15-tips-to-keep-in-mind/](https://gitprotect.io/blog/github-security-best-practices-15-tips-to-keep-in-mind/)  
59. Click Here to Learn About GitHub Security & Best Practices, accessed on April 2, 2025, [https://www.legitsecurity.com/github-security-best-practices](https://www.legitsecurity.com/github-security-best-practices)  
60. Best practices for securing accounts \- GitHub Docs, accessed on April 2, 2025, [https://docs.github.com/en/code-security/supply-chain-security/end-to-end-supply-chain/securing-accounts](https://docs.github.com/en/code-security/supply-chain-security/end-to-end-supply-chain/securing-accounts)  
61. Quickstart for securing your repository \- GitHub Docs, accessed on April 2, 2025, [https://docs.github.com/en/code-security/getting-started/quickstart-for-securing-your-repository](https://docs.github.com/en/code-security/getting-started/quickstart-for-securing-your-repository)  
62. Managing security and analysis settings for your repository \- GitHub Docs, accessed on April 2, 2025, [https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-security-and-analysis-settings-for-your-repository](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-security-and-analysis-settings-for-your-repository)  
63. Creating custom deployment protection rules \- GitHub Docs, accessed on April 2, 2025, [https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-deployments/creating-custom-deployment-protection-rules](https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-deployments/creating-custom-deployment-protection-rules)  
64. Security hardening for GitHub Actions, accessed on April 2, 2025, [https://docs.github.com/en/actions/security-for-github-actions/security-guides/security-hardening-for-github-actions](https://docs.github.com/en/actions/security-for-github-actions/security-guides/security-hardening-for-github-actions)  
65. GitHub Advanced Security · Built-in protection for every repository, accessed on April 2, 2025, [https://github.com/security/advanced-security](https://github.com/security/advanced-security)  
66. 5 GitHub Security Best Practices \- Beyond Identity, accessed on April 2, 2025, [https://www.beyondidentity.com/resource/5-github-security-best-practices](https://www.beyondidentity.com/resource/5-github-security-best-practices)  
67. Security best practices for GitHub \- Spectral, accessed on April 2, 2025, [https://spectralops.io/resources/how-to-choose-a-secret-scanning-solution-to-protect-credentials-in-your-code/](https://spectralops.io/resources/how-to-choose-a-secret-scanning-solution-to-protect-credentials-in-your-code/)  
68. 10 GitHub Security Best Practices \- Snyk, accessed on April 2, 2025, [https://snyk.io/blog/ten-git-hub-security-best-practices/](https://snyk.io/blog/ten-git-hub-security-best-practices/)  
69. About large files on GitHub \- GitHub Docs, accessed on April 2, 2025, [https://docs.github.com/repositories/working-with-files/managing-large-files/about-large-files-on-github](https://docs.github.com/repositories/working-with-files/managing-large-files/about-large-files-on-github)  
70. About Git Large File Storage \- GitHub Docs, accessed on April 2, 2025, [https://docs.github.com/repositories/working-with-files/managing-large-files/about-git-large-file-storage](https://docs.github.com/repositories/working-with-files/managing-large-files/about-git-large-file-storage)  
71. Repository limits \- GitHub Docs, accessed on April 2, 2025, [https://docs.github.com/en/repositories/creating-and-managing-repositories/repository-limits](https://docs.github.com/en/repositories/creating-and-managing-repositories/repository-limits)  
72. GitHub Storage Limits \- Blog \- GitProtect.io, accessed on April 2, 2025, [https://gitprotect.io/blog/github-storage-limits/](https://gitprotect.io/blog/github-storage-limits/)  
73. About GitHub Pages, accessed on April 2, 2025, [https://docs.github.com/en/pages/getting-started-with-github-pages/about-github-pages](https://docs.github.com/en/pages/getting-started-with-github-pages/about-github-pages)  
74. About storage and bandwidth usage \- GitHub Docs, accessed on April 2, 2025, [https://docs.github.com/en/repositories/working-with-files/managing-large-files/about-storage-and-bandwidth-usage](https://docs.github.com/en/repositories/working-with-files/managing-large-files/about-storage-and-bandwidth-usage)  
75. Best Practices for Large-Scale Repositories \- OneNine, accessed on April 2, 2025, [https://onenine.com/best-practices-for-large-scale-repositories/](https://onenine.com/best-practices-for-large-scale-repositories/)  
76. Git Tips 3: Really Large Repositories \- GitButler, accessed on April 2, 2025, [https://blog.gitbutler.com/git-tips-3-really-large-repositories/](https://blog.gitbutler.com/git-tips-3-really-large-repositories/)  
77. Git Large File Storage (LFS) \- GitLab Docs, accessed on April 2, 2025, [https://docs.gitlab.com/topics/git/lfs/](https://docs.gitlab.com/topics/git/lfs/)  
78. About Git Large File Storage and GitHub Desktop, accessed on April 2, 2025, [https://docs.github.com/en/desktop/configuring-and-customizing-github-desktop/about-git-large-file-storage-and-github-desktop](https://docs.github.com/en/desktop/configuring-and-customizing-github-desktop/about-git-large-file-storage-and-github-desktop)  
79. Managing large files \- GitHub Docs, accessed on April 2, 2025, [https://docs.github.com/en/repositories/working-with-files/managing-large-files](https://docs.github.com/en/repositories/working-with-files/managing-large-files)  
80. Git Large File Storage (LFS) Overview \- DataCamp, accessed on April 2, 2025, [https://www.datacamp.com/tutorial/git-large-file-storage-lfs](https://www.datacamp.com/tutorial/git-large-file-storage-lfs)  
81. Collaboration with Git Large File Storage \- GitHub Docs, accessed on April 2, 2025, [https://docs.github.com/en/repositories/working-with-files/managing-large-files/collaboration-with-git-large-file-storage](https://docs.github.com/en/repositories/working-with-files/managing-large-files/collaboration-with-git-large-file-storage)  
82. Git LFS (Git Large File Storage) Overview | Perforce Software, accessed on April 2, 2025, [https://www.perforce.com/blog/vcs/how-git-lfs-works](https://www.perforce.com/blog/vcs/how-git-lfs-works)  
83. Scaling Git to 1TB of files with GitLab and Anchorpoint using Git LFS, accessed on April 2, 2025, [https://www.anchorpoint.app/blog/scaling-git-to-1tb-of-files-with-gitlab-and-anchorpoint-using-git-lfs](https://www.anchorpoint.app/blog/scaling-git-to-1tb-of-files-with-gitlab-and-anchorpoint-using-git-lfs)  
84. Best Practices for Securing Git LFS on GitHub, GitLab, Bitbucket, and Azure DevOps \- Blog, accessed on April 2, 2025, [https://gitprotect.io/blog/best-practices-for-securing-git-lfs-on-github-gitlab-bitbucket-and-azure-devops/](https://gitprotect.io/blog/best-practices-for-securing-git-lfs-on-github-gitlab-bitbucket-and-azure-devops/)